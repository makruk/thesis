\documentclass[13pt]{jarticle}

\makeatletter

\def\@thesis{平成26年度 \\ 信州大学工学部情報工学科卒業論文}
\def\id#1{\def\@id{#1}}
\def\department#1{\def\@department{#1}}

\def\@maketitle{
  \begin{center}
  {\LARGE \@thesis \par}
  \vspace{10mm}
  {\huge\bf \@title \par}
  \vspace{30mm}
  {\Large \@department \par}
  {\Large 学籍番号　\@id \par}
  \vspace{10mm}
  {\Large \@author}
  \end{center}
  \par\vskip 1.5em
  \newpage
}

\makeatother

\title{画面遷移モデルを基にしたシナリオ作成支援}
\department{海尻・小形研究室}
\id{11T5048H}
\author{中村　哲真}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{序論}
\subsection{背景}
ソフトウェア開発の上流工程では，主に設計が行われる．この時，適切に設計されていることは重要である．なぜなら，設計はソフトウェア開発全体の基となり，設計に含まれる問題は実際のソフトウェアに含まれてしまうためである．また，設計に問題がある場合，早期にそれを発見することも重要である．問題を解決する際には，問題にかかわる実装済みの部分をすべて修正する必要があり，発見が遅れると修正箇所が多くなるためである．

設計段階に問題を検証する方法として，入力保存機能に着目したモデル駆動ユーザビリティ評価法の提案と評価が提案されている．この手法ではUML (Unified Modeling Language) を拡張し，システムの画面遷移モデルと，システムの利用上想定されるシナリオを定義している．これにより，上流工程でユーザビリティに関する問題が発見できる．しかし，この手法のシナリオを手動で入力することは煩雑である．例えば，この手法ではシナリオを作成する時，多くの類似した値を入力しなければならない．また，正しいシナリオを作成するには手法を熟知している必要がある．この手法ではUMLを拡張しているため，拡張部分を理解しなければ正しいシナリオを作成できない．

このように手法の利用に対する障壁が高い場合，実際の開発では適用されない可能性が高くなる．従って，実用するためには利用に対する障壁を取り除く必要がある．

\subsection{目的}
本研究は，ソフトウェア開発の上流工程において，特にユーザビリティに関する問題の発見を支援することを目的とする．上流工程でユーザビリティの評価を行う手法は存在する\footnote[1]{入力保存機能に着目したモデル駆動ユーザビリティ評価法の提案と評価}が，利用に対する障壁が大きい．

上流工程で発生した問題を早期に発見するために，入力保存機能に着目したモデル駆動ユーザビリティ評価法の提案と評価(以下，「適用する手法」)\footnotemark[1]で提案されているシナリオの作成支援を行う．

\subsection{論文の構成}
第二章では適用する手法に関する語句を説明する．第三章では関連研究について述べる．第四章では手法の説明を行い，第五章では評価について述べる．第六章ではまとめと今後の課題について述べる．

\newpage

\section{用語説明}
\subsection{画面遷移モデル}
画面遷移モデルとは，システム上の画面間の遷移を定義するモデルである．クラス図上に画面および遷移が記述される．画面遷移モデルの記法はメタモデルで定義されている(図\ref{fig:transitionMetaModel})．

\allowbreak
記法について説明する．画面 (Screen) はクラスとして表され，名前 (Screen.name) および操作項目 (OperatableItem) を持つ．操作項目は名前およびユーザー意図 (OperatableItem.ui) を持ち，遷移 (Transition) と入力項目 (InputItem) に分かれる．遷移は対象の画面を持つ．入力項目には入力型 (InputType) があり，入力された値の保存範囲を持つ．また，平均入力量 (metricsOfUserEffort.avg) と一画面入力限度数 (metricsOfUserEffort.upto) を持つ．入力項目は文字列入力 (InputText)，単一選択(SingleSelection)，複数選択(MultipleSelection)に分かれる．

ユーザー意図はユーザーが画面遷移する動機を表し，作成 (Create)，閲覧 (Browse)，更新 (Update)，削除 (Delete)，取消 (Cancel)の5種類に分けられる．また，ユーザー意図は操作対象画面 (UserIntention.ots) を持つ．これはユーザー意図の対象となる画面を表し，操作対象が遷移先でない場合に明示される．

\subsection{画面インスタンス}
画面インスタンスとは，画面 (Screen) のインスタンスで，各画面で入力された値が格納される．これには以下の6個の拡張記法が定義されている．

\begin{description}
  \item[\texttt{<<delete>>}]{画面インスタンスが削除されたことを示す．}
  \item[\texttt{<<update>>}]{画面インスタンスが更新されたことを示す．}
  \item[\texttt{<<cancel>>}]{入力された値が取り消されたことを示す．}
  \item[\texttt{<<destination>>}]{意図の中で最後に到達する画面インスタンスであることを示す．}
  \item[\texttt{\symbol{92}}a]{入力値および画面インスタンス名に対する拡張記法．入力値がシステムによる自動入力であることを示す．}
  \item[\texttt{\symbol{92}},]{入力値に対する拡張記法．一つの項目に対して複数の値を入力する際に用いる．}
\end{description}

\subsection{シナリオ}
適用する手法のシナリオは，想定されるユーザーの入力が記述される．また，シナリオに操作順序は記述されない．操作順序を記述した場合，画面遷移モデルが変更された際にシナリオを修正する必要があるためである．

シナリオは意図と呼ばれる単位で分割される．これはユーザーが行動する指向のことである．例えば，商品を購入する，カートに入れた商品を修正する等．

シナリオは以下の5種類のオブジェクト図で記述され，ユーザーの入力はオブジェクト図上に画面インスタンスで記述される．
\begin{description}
  \item[開始 (Start)]{シナリオの起点となる画面インスタンスを一つ含む}
  \item[事前条件 (Precondition)]{シナリオ開始前に存在する画面インスタンスを任意の数含む}
  \item[意図 (Intention)]{各意図で入力される画面インスタンスを含む}
  \item[事後条件 (Postcondition)]{シナリオ完了後に存在している画面インスタンスを含む}
  \item[終了 (End)]{シナリオの終点となる画面インスタンスを一つ含む}
\end{description}
なお，シナリオに対して意図は複数存在し，他のオブジェクト図は一つ存在する．

\section{関連研究}

\section{提案手法}
本研究では，シナリオの作成支援ツール(以下，「本支援ツール」)を実装した．プラグインにより拡張可能であり，適用する手法が利用していることから，本支援ツールはastah*を利用した．また，astah* Plug-inはJavaで記述する必要があるため，実装はJavaで行い，GUI部品の表示はswing，awtを利用した．

本支援ツールは画面遷移モデルを解釈して対象のシステムをシミュレートし，開発者に実際に操作させることで，シナリオの作成を支援する．すなわち，webブラウザーのように画面遷移モデルをブラウジングし，値を入力することでシナリオを作成する．これにより，以下の効果を期待する．第一に，拡張記法をツールが補完し，手法の初学者が文法的な誤りを犯さない効果．第二に，ツールが以前入力した値を保持し，入力量を低減する効果である．

図\ref{fig:wholeOfSupportSystem}に本支援ツールの構造を示し，主要なクラスを解説する．

SupportSystemはエントリーポイントである．このクラスはシナリオ作成全体の状態を管理する．さらにBrowser，ScenarioCreator，ModelListener等の主要クラスの初期化を行い，GUIを実際に描画する部分も担う．

Browserは核となる部分である．このクラスはScreen（画面）の表示と画面遷移を行う．Screenの表示は，GUI部品の構成を担うComponentManagerにScreenを渡し，それを表示する．画面遷移は，ButtonComponentから通知を受け，遷移を行う．また，Historyへの値の格納も行う．

ScenarioCreatorは，Historyに格納された値および，設定されたPrecondition（事前条件）を元にシナリオを生成する．

\subsection{画面遷移モデルの解釈}
対象のシステムをシミュレートするため，画面遷移モデルを解釈する．

Screen（画面）からGUIを構成する．ScreenはOperatableItemを保持しており，これはGUI部品に相当する．OperatableItemの実体はTransition（遷移）もしくはInputItem（入力項目）である．従って，Transitionには操作可能なGUI部品を，InputItemには入力可能なGUI部品を割り当てる．本支援ツールではTransitionがButtonComponentに，InputItemがInputComponentに対応している(図\ref{fig:component_inputItem})．

\subsubsection{ButtonComponent}
ButtonComponentは操作可能なボタンとして扱われる．また，内部的にはTransitionの他にUserIntentionを持つ．これはどのような意図を持って画面遷移を行ったかを示すもので，シナリオの構成に必要な情報である．

ButtonComponentは押されたとき，Browserへ押されたことを通知する．また，Browserは通知された時，どの意図で遷移を行うか選択肢を提示する．この時提示される選択肢はButtonComponentに含まれるUserIntentionによって生成される．更新，削除など，対象のインスタンスを指定する遷移の場合，本支援ツールが保持している画面インスタンスを基に選択肢が追加される．また，特別な選択肢として意図のない遷移を追加する．これはシナリオには書き出されない遷移で，明示的に行う必要のない遷移が該当する．

\subsubsection{InputComponent}
InputComponentは複数のGUI部品の集合として扱われる．内部に複数の入力項目 (InputItemInterface) を持つためである．これはInputTypeおよびInputItemInstanceに相当し，入力方法の指定，値の格納を担う．これにより，特定の画面内の一種類の項目に対して複数の値の格納が可能になる(図\ref{fig:inputComponent})．また，入力項目を追加するボタン，指定入力項目を削除するボタンもInputComponentに格納される．

InputItemInterfaceはInputTypeに従い，以下の三種類の実装を持つ．
\begin{description}
\item[InputTextComponent（文字列入力）]{InputTextに対応し，文字列入力可能な部品として扱われる．}
\item[MultipleSelectionComponent（複数選択）]{MultipleSelectionに対応し，選択および文字列入力可能な部品として扱われる．}
\item[SingleSelectionComponent（単一選択）]{SingleSelectionに対応し，選択および文字列入力可能な部品として扱われる．}
\end{description}
選択肢は画面遷移モデル上で定義されていないため，選択項目は文字列入力可能な部品になる．

\subsubsection{GUIの構成}
GUIの構成はComponentManagerが担う．Screen（画面）からButtonComponentおよびInputComponentを生成し，レイアウトを行う．レイアウトは上段に入力項目，下段に操作項目を配置する(図\ref{fig:componentSS})．

この時，同一の名前の操作項目が定義されていることがある．ボタンに表示すると判別がつかないため，同一の名前の操作項目が配置される場合にはボタンのラベルを「操作項目名 - 遷移先の画面名」に変更し，判別可能にする．

また，配置する際にInputComponentに元のInputItem.nameをラベルとして付加する．

\subsection{シナリオ作成に必要な要素}
シナリオ作成に必要な要素を述べるにあたり，シナリオ作成の順序に従って述べる．シナリオ作成は，主に図\ref{fig:scenariOutline}に示す四段階に分かれる．

\subsubsection{初期化}
最初に，正常にシナリオを作成するため，初期化を行う．初期状態では，Browser，ScenarioCreator，ModelListenerのすべてが初期状態になる．また，画面遷移モデルの読み込みは行わない．

\subsubsection{事前条件設定}
シナリオを作成する際，初めに事前条件 (Precondition)を設定する．事前条件の設定では任意の画面クラスから画面インスタンスを作成するか，既存の画面インスタンスを利用する．

従って，任意の画面クラスまたは画面インスタンスを選択する必要がある．そこで，ModelListenerを使用する．ModelListenerはエディタ上で図要素の選択状態が変化した際に呼ばれ，選択している図要素が取得可能になる．

この時，選択した画面クラスあるいは画面インスタンスをComponentManagerを用いて表示する．この時入力された値で画面インスタンスを作成し，Preconditionに画面インスタンスを追加する．

また，画面クラス，画面インスタンスを取得する必要があるため，この時に画面遷移モデルを読み込む．

\subsubsection{シナリオ作成}
シナリオ作成ではBrowserを使用する．Browserは遷移を決定し，遷移の意図および入力された値をHistoryに格納する．このとき，値はScreenStateとして保存される．

ScreenStateには入力されたコンポーネント，対象の画面，遷移の意図，画面インスタンス名，対象インスタンスが格納される．これらの要素はシナリオの生成に必要である．また，ScreenStateを一つの単位とし，Undo，Redo操作を実現した．値の入力は間違える可能性があり，その際に最初から作成し直すことは明白にコストが高いからである．

実装は二つのスタックを用いた（図\ref{fig:undo_redo}）．通常の入力値はスタックhistoryへ格納していく．Undo操作を行う際にはhistoryから一つ取り出し，一時的なスタックtemporaryへ格納する．Redo操作を行う際にはtemporaryから一つ取り出し，historyへ格納する．

また，Browserは現在シミュレートしているシステム内の画面インスタンス郡，内部状態(internalState) を持つ．これにより，作成された画面インスタンスが再利用可能になる．この時，Undo/Redo操作による内部状態の変更が問題になる．Undo/Redoされた操作により値が更新された場合，更新される前の値が保存されていないため，内部状態に不整合が起こる．

この問題に対応するため，二つの解決策を考案した．一つは，ScreenStateに内部状態を持たせ，Undo/Redoする度に内部状態を更新する方法であるこの方法はメモリーの消費が大きいが，計算時間を抑えられる．もう一つは，Undo/Redoする度に内部状態を再度計算しなおす方法である．この方法はメモリーの消費は小さいが，計算時間がかかる．双方実装し使用したところ，顕著な差は見られなかった．従って，今回は後者の方法を採用した．

\subsection{シナリオの導出}
最後に，シナリオを導出する．これは本支援ツールが自動で行う．また，実際にオブジェクト図を操作するため，ModelEditorを使用する．導出にはHistoryとPreconditionを用いる．以下に導出の手順を示す．

最初に，Preconditionを生成する．これには与えられたPreconditionをそのままオブジェクト図に書き出す．

次に，Startを生成する．一番初めの画面インスタンスはHistoryの底に格納されているため，これをオブジェクト図に書き出す．

次にシナリオの核となるIntentionを生成する．Historyを順番に参照し，オブジェクト図に書き出す．この時，画面インスタンス生成時の意図が無い場合，シナリオの構成上必要がないと判断し，書き出されない．

また，意図の変わり目は意図Createによる遷移と意図Updateによる遷移の間にあると考えた[要検証]．そこで，意図Createによる遷移の後を状態Createとし，意図Updateによる遷移の後を状態Updateして，状態が変化した場所を意図の変わり目とした．また，初期状態は最初に行われた意図Createもしくは意図Updateの遷移により決定する．

Intentionの生成と並行し，Postconditionを生成する．Postconditionは最終的なシナリオの状態なので，Preconditionと各Intentionを合成したものになる．そのため，Intentionと同時に生成し，オブジェクト図に書き出す．

最後にEndを生成する．これはHistoryの先頭に格納されている画面インスタンスをオブジェクト図に書き出す．

\section{評価}
\subsection{評価方法}
[この章は評価計画が確定した後，記述する．]

\subsection{考察・結果}
[この章は評価実験の後，記述する．]

\section{結論}
\subsection{まとめ}

\subsection{今後の課題}

[評価実験の後，追記する]
\end{document}