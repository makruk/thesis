\documentclass[12pt]{jsarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{endnotes}
\renewcommand{\theendnote}{[\arabic{endnote}]}
\renewcommand{\notesname}{参考文献}
\usepackage{etoolbox}
\patchcmd{\enoteformat}{1.8em}{0pt}{}{}

\makeatletter

\def\@thesis{平成26年度 \\ 信州大学工学部情報工学科卒業論文}
\def\id#1{\def\@id{#1}}
\def\department#1{\def\@department{#1}}

\def\@maketitle{
  \begin{center}
  {\LARGE \@thesis \par}
  \vspace{10mm}
  {\huge\bf \@title \par}
  \vspace{30mm}
  {\Large \@department \par}
  {\Large 学籍番号　\@id \par}
  \vspace{10mm}
  {\Large \@author}
  \end{center}
  \par\vskip 1.5em
  \newpage
}

\makeatother

\title{画面遷移モデルに基づく\\シナリオ作成支援}
\department{海尻・小形研究室}
\id{11T5048H}
\author{中村　哲真}

\begin{document}
\maketitle
\tableofcontents

\newpage

\section{序論}
\subsection{背景}
ソフトウェア開発において，設計は上流工程で行われる．この時，設計に含まれる問題は最小にすべきである．なぜなら，設計はソフトウェア開発全体の礎となり，設計に含まれる問題は完成したソフトウェアに含まれてしまうためである．また，設計に問題がある場合，早期の発見が重要である．なぜなら，問題を解決する際，問題に関わる成果物をすべて修正する必要があり，工程が進むとその問題の影響を受ける成果物が多くなるためである．

設計段階に問題を検証する方法として，入力保存機能に着目したモデル駆動ユーザビリティ評価法の提案と評価\endnote[1]{小形真平，早川弘基，2011年，『入力保存機能に着目したモデル駆動ユーザビリティ評価法の提案と評価』}が提案されている．この手法ではUML (Unified Modeling Language) を拡張し，評価対象のシステムを表す画面遷移モデルと，ユーザーの入力を想定するシナリオを定義している．これを用いて，ユーザーが感じる入力負担の大きさを定量的に評価する．この手法を用いることで，上流工程においてユーザビリティの評価が可能となる．

しかし，この手法に必要なモデルを手動で作成することは開発者にとって負担が大きい．以下に既知の問題点を示す．
\begin{itemize}
  \item 類似した，あるいは同一の値を複数入力することがあり，記述量が多くなる
  \item 拡張記法が多く，正しくシナリオを作成するには拡張記法の理解が必要
  \item 記述を誤った場合，正しい結果が得られない
\end{itemize}

これらように，入力保存機能に着目したモデル駆動ユーザビリティ評価法の提案と評価\endnotemark[1](以下，「対象手法」)は利用する際の難度が高い．手法の難度が高い場合，実際の開発では適用されない可能性が高くなる．従って，実用するためには難度を下げる必要がある．

\subsection{目的}
本研究は，ソフトウェア開発の上流工程において，特にユーザビリティに関する問題の発見を支援することを目的とする．上流工程でユーザビリティの評価を行う手法は存在する\endnotemark[1]が，利用難度が高く，実際の開発では適用されない可能性が高い．そこで，利用難度を下げるため，シナリオの作成を支援するツールを開発する．方針としては，入力された値をツールが記憶し，必要な場所で自動入力することで記述量を低減させる．また，拡張された記法をツールが補完し，初学者のシナリオ作成を補助する．

評価として，実際に手法を適用し，正しいシナリオを記述可能か検証する．

\subsection{論文の構成}
第二章では対象手法\endnotemark[1]に関する語句を説明する．第三章では関連研究について述べる．第四章では手法の説明を行い，第五章では評価について述べる．第六章ではまとめと今後の課題について述べる．

\newpage

\section{用語説明}
\subsection{画面遷移モデル}
画面遷移モデルとは，システム上の画面間の遷移を定義するモデルである．クラス図上に画面および遷移が記述される(図\ref{fig:transitionModel})．画面遷移モデルの記法を定義するメタモデルを図\ref{fig:transitionMetaModel}に示す．

\begin{figure}[htbp]
\includegraphics[width=10cm]{transitionModel.eps}
\caption{画面遷移モデル}
\label{fig:transitionModel}
\end{figure}

\begin{figure}[htbp]
\includegraphics[width=10cm]{transitionMetaModel.eps}
\caption{画面遷移モデルのメタモデル}
\label{fig:transitionMetaModel}
\end{figure}

記法について説明する．画面 (Screen) はクラスとして表され，操作項目 (OperatableItem) を持つ．操作項目はユーザー意図(UserIntention)と平均入力量(MetricsOfUserEffort.avg)，一画面入力限度数(MetricsOfUserEffort.upto)を持つ．また，操作項目の実体は遷移 (Transition) または入力項目 (InputItem) に分類される．遷移は関係として，入力項目は属性として画面に保持される．

入力項目は入力型 (InputType) を持ち，文字列入力 (InputText)，単一選択(SingleSelection)，複数選択(MultipleSelection)に分類される．

ユーザー意図はユーザーが画面遷移する動機を表し，以下の5種類に分類される．
\begin{description}
  \item[作成 (Create)]{遷移先のインスタンスを作成する}
  \item[閲覧 (Browse)]{遷移先のインスタンスを変更しない}
  \item[更新 (Update)]{遷移先のインスタンスを更新する}
  \item[削除 (Delete)]{指定したインスタンスを削除する}
  \item[取消 (Cancel)]{遷移元のインスタンスの作成，更新を取り消す}
\end{description}
また，ユーザー意図は操作対象画面 (UserIntention.ots) を持つ．これはユーザー意図の対象となる画面を表し，操作対象が遷移先でない場合に明示される．

\subsection{画面インスタンス}
画面インスタンスは，画面 (Screen)をインスタンス化したもので，各画面で入力された値が格納される．これには以下の6個の拡張記法が定義されている．

\begin{description}
  \item[\texttt{<<delete>>}]{画面インスタンスが削除されたことを示す．}
  \item[\texttt{<<update>>}]{画面インスタンスが更新されたことを示す．}
  \item[\texttt{<<cancel>>}]{入力された値が取り消されたことを示す．}
  \item[\texttt{<<destination>>}]{意図の中で最後に到達する画面インスタンスであることを示す．}
  \item[\texttt{\symbol{92}}a]{入力値および画面インスタンス名に対する拡張記法．入力値がシステムによる自動入力であることを示す．}
  \item[\texttt{\symbol{92}},]{入力値に対する拡張記法．一つの項目に対して複数の値を入力する際に用いる．}
\end{description}

\subsection{シナリオ}
対象手法のシナリオには，想定されるユーザーの入力が記述される．また，シナリオに操作順序は記述されない．操作順序を記述した場合，画面遷移モデルが変更された際にシナリオを修正する必要があるためである．

シナリオは意図と呼ばれる単位で分割される．これはユーザーの行動指向のことである．例えば，商品を購入する，カートに入れた商品を修正する等である．

シナリオは以下の5種類のオブジェクト図で記述され，ユーザーの入力はオブジェクト図上に画面インスタンスで記述される．
\begin{description}
  \item[開始 (Start)]{シナリオの起点となる画面インスタンスを一つ記述する}
  \item[事前条件 (Precondition)]{シナリオ開始前に存在する画面インスタンスを任意の数記述する}
  \item[意図 (Intention)]{各意図で入力される画面インスタンスを記述する}
  \item[事後条件 (Postcondition)]{シナリオ完了後に存在している画面インスタンスを記述する}
  \item[終了 (End)]{シナリオの終点となる画面インスタンスを一つ記述する}
\end{description}
なお，シナリオに対して意図のオブジェクト図は複数存在し，他のオブジェクト図は一つずつ存在する．

\newpage

\section{関連研究}


\section{提案手法}
本研究では，シナリオの作成を支援するツール(以下，「本ツール」)を設計し，実装した．プラグインにより拡張可能であり，対象手法が利用していることから，本ツールはastah*のプラグインとして実装した．また，astah* Plug-inはJavaで記述する必要があるため，実装はJavaで行い，GUI部品の表示はswing，awtを利用した．

本ツールは画面遷移モデルを解釈して対象のシステムをシミュレートし，GUIで表示する．これを開発者が実際に対象のシステムを利用するように操作する．この操作の内容を本ツールが記憶し，シナリオを生成する．

これにより，以下の効果を期待する．第一に，拡張された記法をツールが補完し，初学者がシナリオを作成した際の文法的な誤りを防止する効果．第二に，ツールが以前入力した値を保持し，入力量を低減する効果である．

図\ref{fig:wholeOfSupportSystem}に本ツールの構造を示す．また主要なクラスを解説する．

\begin{figure}[htbp]
\includegraphics[width=15cm]{wholeOfSupportSystem.eps}
\caption{シナリオの作成支援ツール構造}
\label{fig:wholeOfSupportSystem}
\end{figure}

SupportSystemは，本ツールのエントリーポイントである．シナリオ作成の進行，Browser，ScenarioCreator，AbstractModelObserver等の主要なクラスの管理を行う．また，GUIを表示する役割を持つ．

Browserは，本ツールの核となる部分である．このクラスはScreen（画面）の表示と画面遷移を行う．GUI部品の構成を担うComponentManagerを持ち，画面遷移に応じて画面を表示する．また，入力された値を管理し，Historyへ格納する．

ScenarioCreatorは，シナリオを生成するクラスである．Historyに格納された値，設定されたPrecondition（事前条件）から，シナリオを生成する．

AbstractModelObserverは抽象クラスで，対象とするエディタの違いを吸収する．エディタ上の要素の選択状態の変化の通知を受け取り，登録されたリスナーへ通知を行う．また，選択された要素を取得する．

\subsection{画面遷移モデルの解釈}
本ツールでは対象のシステムをシミュレートする．そのために画面遷移モデルを解釈し，画面を構成し，画面遷移を実現する．

Screen（画面）からGUIを構成する．図\ref{fig:component_inputItem}に，対象となる手法の画面遷移モデル(一部)と，それに関係する本ツールの構造を示す．

ScreenはOperatableItemを保持しており，これはGUI部品に相当する．OperatableItemの実体はTransition（遷移）もしくはInputItem（入力項目）である．従って，Transitionには操作可能なGUI部品を，InputItemには入力可能なGUI部品を割り当てる．本ツールではTransitionがButtonComponentに，InputItemがInputComponentに対応している．

\begin{figure}[htbp]
\includegraphics[width=10cm]{component_inputItem.eps}
\caption{対象となる手法と本ツールの関係(上：対象となる手法)}
\label{fig:component_inputItem}
\end{figure}

\subsubsection{ButtonComponent}
ButtonComponentは操作可能なボタンとして扱われる．また，内部的にはTransitionの他にUserIntention（ユーザー意図）を持ち，どのような意図で遷移可能かを示す．

ButtonComponentは押されたとき，Browserへ押されたことを通知する．また，Browserは通知された時，どの意図で遷移を行うか選択肢を提示する．この時提示される選択肢はButtonComponentが持つUserIntentionによって生成される．また，本ツールでは特別な選択肢として意図のない遷移も提示される．これはシナリオには書き出されない遷移で，シナリオ上明示的に行う必要のない遷移が該当する．

更新，削除など，対象のインスタンスを指定して遷移を行う場合がある．この場合，対象になる可能性のある画面インスタンスが選択肢に追加される．

\subsubsection{InputComponent}
InputComponentは複数のGUI部品の集合として扱われる．内部に複数の入力項目 (InputItemInterface) を持つためである．入力項目は対象手法のInputTypeおよびInputItemInstanceに相当し，入力種別の指定，値の格納，取り出しを担う．これにより，入力項目が複数の値の入力を許可していた場合，複数の値の格納が可能になる(図\ref{fig:inputComponent})．また，入力項目を追加するボタン，指定入力項目を削除するボタンもInputComponentに格納される．

\begin{figure}[htbp]
\includegraphics[width=10cm]{inputComponent.eps}
\caption{InputComponentの構造}
\label{fig:inputComponent}
\end{figure}

InputItemInterfaceはInputTypeに従い，以下の三種類の実装を持つ．
\begin{description}
\item[InputTextComponent（文字列入力）]{InputTextに対応し，文字列の入力が可能な部品として扱われる．}
\item[MultipleSelectionComponent（複数選択）]{MultipleSelectionに対応し，値の選択および文字列の入力が可能な部品として扱われる．}
\item[SingleSelectionComponent（単一選択）]{SingleSelectionに対応し，値の選択および文字列の入力が可能な部品として扱われる．}
\end{description}
選択肢は画面遷移モデル上で定義されていないため，選択項目は文字列入力可能な部品になる．

\subsubsection{GUIの構成}
GUIの構成はComponentManagerが行う．Screen（画面）からButtonComponentおよびInputComponentを生成し，配置する．レイアウトは上下段にわかれ，図\ref{fig:componentSS}のように上段に入力項目，下段に操作項目が配置される．

\begin{figure}[htbp]
\includegraphics[width=14cm]{componentSS.eps}
\caption{構成されたGUI部品}
\label{fig:componentSS}
\end{figure}

ButtonComponentを配置する時，図\ref{fig:componentSS}の「次の画面へ進む」のように，同一の名前の操作項目が定義されていることがある．実際に表示すると判別がつかないため，同一の名前の操作項目が配置される場合には，ボタンのラベルを「操作項目名-遷移先の画面名」に変更し，判別可能にする．

また，InputComponentを配置するとき，どの値の入力項目か判別するため，項目の名前をラベルとして付加する．

\subsection{シナリオ作成の手順}
シナリオの作成を順を追って述べる．シナリオ作成は，図\ref{fig:scenarioOutline}に示す四段階に分かれる．

\begin{figure}[htbp]
\includegraphics[width=5cm]{scenarioOutline.eps}
\caption{シナリオ作成の手順}
\label{fig:scenarioOutline}
\end{figure}

\subsubsection{初期化}
最初に，正常にシナリオを作成するため，各クラスの初期化を行う．Browser，ScenarioCreator，ModelListenerを初期化する．また，この段階までに画面遷移モデルが完成している必要がある．

\subsubsection{事前条件設定}
シナリオを作成する際，初めに事前条件 (Precondition)を設定する．事前条件の設定では任意の画面から画面インスタンスを作成するか，既存の画面インスタンスを再利用する．この時に画面遷移モデルを読み込む．

事前条件の設定時には，任意の画面クラスまたは画面インスタンスを開発者が選択し，本ツールが認識する必要がある．そこで，ModelObserverを利用する．選択状態の変化の通知をModelObserverから受け，選択した要素を取得する．

この時，選択した画面クラスあるいは画面インスタンスをComponentManagerを用いて表示する．さらに，入力された値で画面インスタンスを作成し，Preconditionに画面インスタンスを追加する．

\subsubsection{対象システムのシミュレート}
対象システムのシミュレートには，Browserを使用する．Browserはユーザーの操作によって遷移を決定し，その意図および入力された値をHistoryに格納する．

このとき，値はScreenStateとして保存される．ScreenStateには入力された項目，対象の画面，遷移の意図，画面インスタンス名，意図の対象のインスタンスが格納される．これらの値は，シナリオの作成に用いる．

また，ScreenStateを一つの単位とし，Undo，Redo操作を実現した．値の入力は間違える可能性があり，その際に最初から作成し直すことは明白にコストが高いためである．実装は二つのスタックを用いた（図\ref{fig:undo_redo}）．通常の入力値はスタックhistoryへ格納していく．Undo操作を行う際にはhistoryから一つ取り出し，一時的なスタックtemporaryへ格納する．Redo操作を行う際にはtemporaryから一つ取り出し，historyへ格納する．

\begin{figure}[htbp]
\caption{未完成}
\label{fig:undo_redo}
\end{figure}

また，Browserは現在シミュレートしているシステムの内部状態(internalState) を，画面インスタンスの集合として持つ．これにより，更新の意図や削除の意図で遷移する際に，既存の画面インスタンスを再利用できる．しかしこの時，Undo/Redo操作による内部状態の変更が問題になる．取り消された操作により値が更新されていた場合，更新される前の値が保存されていないため，内部状態に不整合が起こる．

この問題に対応するため，二つの解決策を考案した．

一つは，ScreenStateに内部状態を持たせ，Undo/Redoする度に内部状態を更新する方法である．この方法はメモリーの消費が大きいが，計算時間を抑えられる．

もう一つは，Undo/Redoする度に内部状態を再度計算しなおす方法である．この方法はメモリーの消費は小さいが，計算時間がかかる．

双方実装し使用したところ，顕著な差は見られなかった．従って，今回は後者の方法を採用した．

\subsection{シナリオの導出}
最後に，シナリオを導出する．これは本ツールが自動で行う．また，実際にオブジェクト図を操作する必要があるため，AstahModelEditorを使用する．

導出にはHistoryとPreconditionを用いる．以下に導出の手順を示す．

最初に，Preconditionを生成する．これには与えられたPreconditionをすべてオブジェクト図に書き出す．

次に，Startを生成する．一番初めの画面インスタンスはHistoryの底に格納されているため，これをオブジェクト図に書き出す．

次にシナリオの核となるIntentionを生成する．Historyを順番に参照し，オブジェクト図に書き出していく．この時，画面に入る際の意図が無い場合，シナリオの構成上必要がないと判断し，書き出されない．

また，意図の変わり目は意図Createによる遷移と意図Updateによる遷移の間にあると考えた[要検証]．そこで，意図Createによる遷移の後を状態Createとし，意図Updateによる遷移の後を状態Updateして，状態が変化したときを意図の変わり目とした．また，初期状態は最初に行われた意図Createもしくは意図Updateの遷移により決定する．

Intentionの生成と並行し，Postconditionを生成する．Postconditionは最終的なシナリオの状態なので，Preconditionと各Intentionを合成したものになる．そのため，Intentionと同時に生成し，オブジェクト図に書き出す．

最後にEndを生成する．Historyの最後の要素をオブジェクト図に書き出す．

\section{評価}
\subsection{評価方法}
[この章は評価計画が確定した後，記述する．]

\subsection{考察・結果}
[この章は評価実験の後，記述する．]

\newpage

\section{結論}
\subsection{まとめ}
本論文では，ソフトウェア開発の上流工程においてユーザビリティに関する問題を発見するための手法\endnotemark[1]で提案されるシナリオの作成支援ツールの実装を紹介，説明した．これにより，手法を適用する障壁が取り除かれ，実際の開発において上流工程に手法\endnotemark[1]を取り入れることを可能にした[要検証・要追記]．

本ツールにより，上流工程においてユーザビリティ評価が行われ，より品質の良い製品が開発されることを期待する．
\subsection{今後の課題}
今後の課題として，コンポーネントの表現の柔軟化が挙げられる．現在，コンポーネントは決まった種類の部品のみ定義されている．しかし，現実にはコンポーネントがコンポーネントを内包したり，他のコンポーネントに関係付けられたりと，様々なコンポーネントが存在する．これの改善案として，コンポーネントの表現を拡張可能にする案が挙げられる．これにより，現実に即したコンポーネントの構成が行える．また，複数選択の選択肢の指定も併せて定義されると良い．

また，他の手法に対して支援を行うことも今後の課題としたい．本ツールは特定の手法\endnotemark[1]にのみ適応できるが，画面遷移モデルが存在し，テストシナリオの生成を目的とする手法であれば支援を行える可能性がある．

[評価実験の後，追記する]
\newpage
\addcontentsline{toc}{section}{\notesname}
\theendnotes
\end{document}