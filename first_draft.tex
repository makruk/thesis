\documentclass[a4paper, 12pt]{jsarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{endnotes}
\renewcommand{\theendnote}{[\arabic{endnote}]}
\renewcommand{\notesname}{参考文献}
\usepackage{etoolbox}
\patchcmd{\enoteformat}{1.8em}{0pt}{}{}

\makeatletter

\def\@thesis{平成26年度 \\ 信州大学工学部情報工学科卒業論文}
\def\id#1{\def\@id{#1}}
\def\department#1{\def\@department{#1}}

\def\@maketitle{
  \begin{center}
  {\LARGE \@thesis \par}
  \vspace{10mm}
  {\huge\bf \@title \par}
  \vspace{30mm}
  {\Large \@department \par}
  {\Large 学籍番号　\@id \par}
  \vspace{10mm}
  {\Large \@author}
  \end{center}
  \par\vskip 1.5em
  \newpage
}

\makeatother

\title{画面遷移モデルに基づく\\シナリオ作成支援}
\department{海尻・小形研究室}
\id{11T5048H}
\author{中村　哲真}

\begin{document}
\maketitle
\tableofcontents

\newpage

\section{序論}
\subsection{背景}
ソフトウェア開発において，設計は上流工程で行われる．この時，設計に含まれる問題は最小にすべきである．なぜなら，設計はソフトウェア開発全体の礎となり，設計に含まれる問題は完成したソフトウェアに含まれてしまうためである．また，設計に問題がある場合，早期の発見が重要である．なぜなら，問題を解決する際，問題に関わる成果物をすべて修正する必要があり，工程が進むとその問題の影響を受ける成果物が多くなるためである．

設計段階に問題を検証する方法として，入力保存機能に着目したモデル駆動ユーザビリティ評価法の提案と評価\endnote[1]{小形真平，早川弘基，海谷治彦，海尻賢二，入力保存機能に着目したモデル駆動ユーザビリティ評価法の提案と評価，コンピュータソフトウェア，Vol.29，No.1(2012)，pp.1-6}が提案されている．この手法ではUML (Unified Modeling Language) を拡張し，評価対象のシステムを表す画面遷移モデルと，ユーザーの入力を想定するシナリオを定義している．これを用いて，ユーザーが感じる入力負担の大きさを定量的に評価する．この手法を用いることで，上流工程においてユーザビリティの評価が可能となる．

しかし，この手法に必要なモデルを手動で作成することは負担が大きい．以下に既知の問題点を示す．
\begin{itemize}
  \item 記述量が多い．類似した，あるいは同一の値を複数入力することがある．
  \item 拡張記法が多く，正しくシナリオを作成するには拡張記法の理解が必要．
  \item 構成が複雑であり，正しく書かれていないと評価が不可能になる．
\end{itemize}

これらように，入力保存機能に着目したモデル駆動ユーザビリティ評価法の提案と評価\endnotemark[1](以下，「対象手法」)は利用する際の難度が高い．手法の難度が高い場合，実際の開発では適用されない可能性が高くなる．

\subsection{目的}
本研究は，ソフトウェア開発の上流工程において，ユーザビリティの問題を発見する手法の支援を行うことを目的とする．上流工程でユーザビリティの評価を行う手法は存在する\endnotemark[1]が，利用難度が高く，実用には適さない．そこで，利用難度を低減するため，シナリオの作成を支援するツールを開発する．

対象手法の問題点および本研究における解決方針を述べる．

第一に，シナリオを作成する際，大量の値を入力する必要がある．このとき，入力する値の中には同一のものや類似しているものがあり，容易に補完できる．よって，入力された値をツールが記憶し，必要な場所で自動入力する．これにより，値の入力量を低減させる．

第二に，拡張記法が多い．対象手法はUMLを拡張しており，手法に不慣れな場合正しく記述できない．これに対して，拡張記法をツールが補完し，手法に不慣れな人のシナリオ作成を補助する．

第三に，シナリオの構成が複雑である．対象手法は五個以上のオブジェクト図を正しく記述しなければならない．本研究では，オブジェクト図への記述をツールが行い，開発者の負担を軽減する．

[add detail]

本研究の評価として，実際にツールを使用し，正しいシナリオを記述可能か検証を行う．

\subsection{論文の構成}
第二章では対象手法\endnotemark[1]に関する語句を説明する．第三章では関連研究について述べる．第四章では手法の説明を行い，第五章では評価について述べる．第六章ではまとめと今後の課題について述べる．

\newpage

\section{用語説明}
\subsection{画面遷移モデル}
\label{sec:aboutScreenTransitionModel}
画面遷移モデルとは，システム上の画面間の遷移を定義するモデルである．本研究ではこれに基づいてシナリオの作成支援を行う．

対象手法ではクラス図上に画面および遷移が記述される(図\ref{fig:transitionModel})．画面遷移モデルの記法を定義するメタモデルを図\ref{fig:transitionMetaModel}に示す．

\begin{figure}[htbp]
\includegraphics[width=10cm]{img/transitionModel.pdf}
\caption{画面遷移モデル}
\label{fig:transitionModel}
\end{figure}

\begin{figure}[htbp]
\includegraphics[width=10cm]{img/transitionMetaModel.pdf}
\caption{画面遷移モデルのメタモデル}
\label{fig:transitionMetaModel}
\end{figure}

画面遷移モデルの記法について説明する．これはメタモデル（図\ref{fig:transitionMetaModel}）で定義されている．括弧内に対応するメタモデルの部分を示す．

画面 (Screen) はシステム上の画面を表し，クラスとして定義される．図\ref{fig:transitionModel}の「ホーム」，「メッセージ」，「連絡先」，「完了」のように，画面名がクラス名として表される．また，遷移 (Transition) を関係として，入力項目 (InputItem) を属性として持つ．

遷移と入力項目の抽象クラスとして，操作項目 (OperatableItem) が存在する．これは操作可能な項目を表し，平均入力量 (MetricsOfUserEffort.avg)，一画面入力限度数 (MetricsOfUserEffort.upto) を持つ．また，項目がどのような意図で操作されたかを示すユーザー意図 (UserIntention)も持つ．

これらは拡張記法で記述される．平均入力量は，一項目に対するユーザーの平均操作回数を表し，「{avg:100}」のように記述される．一画面入力限度数は，一画面で一項目に入力できる値の個数の上限を表し，「{upto:5}」のように記述される．また，ユーザー意図は，「{ui:作成}」のように記述される（図\ref{fig:transitionModel}）．

ユーザー意図は以下の五種類に分類される．
\begin{description}
  \item[作成 (Create)]{値を作成する}
  \item[閲覧 (Browse)]{値を変更しない}
  \item[更新 (Update)]{値を更新する}
  \item[削除 (Delete)]{値を削除する}
  \item[取消 (Cancel)]{遷移元の値の作成，更新を取り消す}
\end{description}

また，ユーザー意図は操作対象画面 (UserIntention.ots) を持つ．これはユーザー意図の対象となる画面を表し，操作対象が遷移先でない場合に明示される．

入力項目は入力型 (InputType) を持つ．これは入力項目の型として表される（図\ref{fig:transitionModel}）．入力型は三種類あり，文字列入力 (InputText)，単一選択(SingleSelection)，複数選択(MultipleSelection)に分類される．

また，入力項目は保存範囲 (InputItem.save) も持つ．これは値の保存範囲を示し，保存範囲外の画面へ遷移した場合に破棄される．例えば，「メッセージ」画面クラスの「メッセージ」属性は，「ホーム」に遷移する際に破棄される（図\ref{fig:transitionModel}）．

\subsection{画面インスタンス}
画面インスタンスは，画面 (Screen) をインスタンス化したもので，各画面で入力された値が格納される．

また，これには以下の六種類の拡張記法が定義されている．

\begin{description}
  \item[\texttt{<<delete>>}]{画面インスタンスが削除されたことを示す．}
  \item[\texttt{<<update>>}]{画面インスタンスが更新されたことを示す．}
  \item[\texttt{<<cancel>>}]{入力された値が取り消されたことを示す．}
  \item[\texttt{<<destination>>}]{意図の中で最後に到達する画面インスタンスであることを示す．}
  \item[\texttt{\symbol{92}}a]{入力値および画面インスタンス名に対する拡張記法．入力値がシステムによる自動入力であることを示す．}
  \item[\texttt{\symbol{92}},]{入力値に対する拡張記法．一つの項目に対して複数の値を入力する際に用いる．}
\end{description}

正しいシナリオを作成するには，拡張記法を適切に記述する必要がある．本研究では記述の誤りを防ぐため，ツールによる拡張記法の自動補完を行う．
[add ex. of instance]
\subsection{シナリオ}
シナリオとは，想定されるユーザーの入力や操作を記述するものである．

対象手法のシナリオでは，想定されるユーザーの入力が画面インスタンスとして記述される．また，個々の画面遷移の操作順序は記述されない．画面遷移に対して細かく操作順序を記述した場合，画面遷移モデルが変更された際にシナリオを修正する必要があるためである．特に，対象手法では入力された値の保存範囲を考えるため，値の保存範囲を変更した場合にも画面遷移の順序が変化する．

しかし，順序が完全に存在しなければ，シナリオが成り立たない．そこで，シナリオを意図と呼ばれる単位で分割する．これはユーザーの行動指向のことである．例えば，商品を購入する，カートに入れた商品を修正する等である．このとき，意図の方向性を明確にするため，最後の画面は明示される．これにより，シナリオに大まかな順序が記述される．

シナリオは以下の5種類のオブジェクト図で記述され，ユーザーの入力はオブジェクト図上に画面インスタンスで記述される．
\begin{description}
  \item[開始 (Start)]{シナリオの起点となる画面インスタンスを一つ記述する}
  \item[事前条件 (Precondition)]{シナリオ開始前に存在する画面インスタンスを任意の数記述する}
  \item[意図 (Intention)]{各意図で入力される画面インスタンスを記述する}
  \item[事後条件 (Postcondition)]{シナリオ完了後に存在している画面インスタンスを記述する}
  \item[終了 (End)]{シナリオの終点となる画面インスタンスを一つ記述する}
\end{description}
なお，シナリオに対して意図のオブジェクト図は複数存在し，他のオブジェクト図は一つずつ存在する．

\newpage

\section{関連研究}


\section{提案手法}
本研究では，シナリオの作成を支援するツール(以下，「本ツール」)を設計し，実装した．プラグインにより拡張可能であり，対象手法が利用していることから，本ツールはastah*のプラグインとして実装した．また，astah* Plug-inはJavaで記述する必要があるため，実装はJavaで行い，GUI部品の表示はawt，swingを利用した．

astah* Plug-inは，astah*に機能を追加する仕組みである．本ツールでは，astah* Plug-inの拡張タブビューを利用した．これは，astah*の下部のフレームを，swingのコンポーネントとして操作可能にするものである．用意されたインターフェース (IPluginExtraTabView) を実現すると利用できる．これを介して，swingのJPanel上に配置したGUI部品をエディタ上に表示できる．

本ツールは画面遷移モデルを解釈して対象のシステムの画面をシミュレートし，GUIで表示する．これを開発者が実際に対象のシステムを利用するように操作する．この操作の内容を本ツールが記憶し，シナリオを生成する．

これにより，以下の効果を期待する．第一に，拡張された記法をツールが補完し，初学者がシナリオを作成した際の文法的な誤りを防止する効果．第二に，以前入力した値をツールがすべて記憶し，適宜挿入することで入力量を低減する効果である．

図\ref{fig:wholeOfSupportSystem}に本ツールの構造を示す．また主要なクラスを解説する．

\begin{figure}[htb]
\begin{center}
\includegraphics[width=14cm]{img/wholeOfSupportSystem.pdf}
\caption{シナリオの作成支援ツール構造}
\end{center}
\label{fig:wholeOfSupportSystem}
\end{figure}

\begin{description}
\item[SupportSystem]{本ツールのエントリーポイントである．シナリオ作成の進行や，Browser，ScenarioCreator，AbstractModelObserver等の主要なクラスの管理を行う．また，GUIを実際に表示する．astah*の場合，このクラスがIPluginExtraTabViewを実現し，astah*上にGUIを配置する．}
\item[Browser]{本ツールの核となる部分である．このクラスはScreen（画面）の表示と画面遷移を行う．GUI部品の構成を担うComponentManagerを持ち，画面遷移に応じて画面を表示する．また，開発者が入力したシナリオの具体値および遷移の意図を管理し，Historyへ格納する．詳しくは，ComponentManagerは\ref{sec:componentManager}章，Browserは\ref{sec:simulate}章で説明する．}
\item[ScenarioCreator]{シナリオを生成するクラスである．Historyに格納されたシナリオの具体値と，事前に設定された，画面インスタンスの集合であるPrecondition（事前条件）から，シナリオを生成する．詳しくは\ref{sec:createScenario}章で説明する．}
\item[AbstractModelObserver]{これは抽象クラスで，対象とするエディタの違いを吸収する．エディタ上のクラスや画面インスタンスの選択状態が変化したとき通知を受け取り，登録されたリスナーのメソッドを実行する．また，選択された要素を取得する．}
\end{description}

\subsection{画面遷移モデルの解釈}
本ツールでは対象のシステムをシミュレートする．そのために画面遷移モデルを解釈し，画面を構成し，画面遷移を実現する．これはComponentManagerで実装している．

Screen（画面）からGUIを構成する．図\ref{fig:component_inputItem}に，対象となる手法の画面遷移モデル(一部)と，それに関係する本ツールの構造を示す．

ScreenはOperatableItemを持つ．対象手法ではこれを「操作項目」としており，ユーザーが操作可能な項目といえる．従って，本ツールではこれをGUI部品に相当するものとして扱う．OperatableItemの実体はTransition（遷移）もしくはInputItem（入力項目）である．従って，Transitionには操作可能なGUI部品を，InputItemには入力可能なGUI部品を割り当てる．本ツールではTransitionがButtonComponentに，InputItemがInputComponentに対応している．

\begin{figure}[htb]
\includegraphics[width=10cm]{img/component_inputItem.pdf}
\caption{対象手法と本ツールの関係(上：対象手法)}
\label{fig:component_inputItem}
\end{figure}

\subsubsection{ButtonComponent}
ButtonComponentは操作可能なボタンとして扱われる．また，内部的にはTransitionの他にUserIntention（ユーザー意図）を持ち，どのような意図で遷移可能かを示す．

ButtonComponentは押されたとき，Browserへ押されたことを通知する．また，Browserは通知された時，どの意図で遷移を行うか選択肢を提示する．この時提示される選択肢は，ButtonComponentが持つUserIntentionによって生成される．さらに，提示された意図を選択すると，その意図による遷移が行われる．

また，本ツールでは特別な選択肢として意図のない遷移も提示される．これはシナリオには書き出されない遷移で，シナリオ上明示的に行う必要のない遷移が該当する．

更新，削除のような，既存の画面インスタンスに変更を加える遷移が存在する．この時，対象のインスタンスを指定する必要がある．そのため，対象になる可能性のある画面インスタンスが選択肢に追加される．

遷移および意図に関する詳細は章\ref{sec:aboutHistory}で詳解する．

\subsubsection{InputComponent}
InputComponentは複数のGUI部品の集合として扱われる．内部に複数の入力項目 (InputItemInterface) を持つためである．入力項目は対象手法のInputTypeおよびInputItemInstanceに相当するインターフェースである．本ツールでは値の入力可能なGUI部品として扱われ，値の格納，取り出しと，GUI部品の取得をメソッドとして持つ．

内部に複数の入力項目を持つため，基となるInputItemが複数の値の入力を許可していた場合，複数の値の格納が可能になる．複数の値の入力については，\ref{sec:aboutScreenTransitionModel}章で説明した一画面入力限度数がこれに当たる．

また，入力項目を追加するボタン，指定入力項目を削除するボタンもInputComponentに格納される（図\ref{fig:inputComponent}）．

\begin{figure}[htb]
\includegraphics[width=10cm]{img/inputComponent.pdf}
\caption{InputComponentの構造}
\label{fig:inputComponent}
\end{figure}

InputItemInterfaceはInputTypeに従い，以下の三種類の実装を持つ．
\begin{description}
\item[InputTextComponent（文字列入力）]{InputTextに対応し，文字列の入力が可能な部品として扱われる．}
\item[MultipleSelectionComponent（複数選択）]{MultipleSelectionに対応し，値の選択および文字列の入力が可能な部品として扱われる．}
\item[SingleSelectionComponent（単一選択）]{SingleSelectionに対応し，値の選択および文字列の入力が可能な部品として扱われる．}
\end{description}

選択項目は，文字列の入力が可能な部品として扱われる．これは選択肢が画面遷移モデル上で定義されていないためである．

\subsubsection{GUIの構成}
\label{sec:componentManager}

GUIの構成はComponentManagerが行う．Screen（画面）からButtonComponentおよびInputComponentを生成し，配置する．レイアウトは上下段にわかれ，図\ref{fig:componentSS}のように上段に入力項目，下段に操作項目が配置される．

\begin{figure}[htbp]
\includegraphics[width=14cm]{img/componentSS.pdf}
\caption{構成されたGUI部品}
\label{fig:componentSS}
\end{figure}

ButtonComponentを配置する時，図\ref{fig:componentSS}の「次の画面へ進む」のように，同一の名前の操作項目が定義されていることがある．実際に表示すると判別がつかないため，同一の名前の操作項目が配置される場合には，ボタンのラベルを「操作項目名-遷移先の画面名」に変更し，判別可能にする．

また，InputComponentを配置するとき，どの値の入力項目か判別するため，項目の名前をラベルとして付加する．

\subsection{シナリオ作成の手順}
シナリオの作成を順を追って述べる．シナリオ作成は，図\ref{fig:scenarioOutline}に示す四段階に分かれる．

\begin{figure}[htbp]
\includegraphics[width=5cm]{img/scenarioOutline.pdf}
\caption{シナリオ作成の手順}
\label{fig:scenarioOutline}
\end{figure}

\subsubsection{初期化}
最初に，正常にシナリオを作成するため，各クラスの初期化を行う．Browser，ScenarioCreator，ModelListenerを初期化する．また，この段階までに画面遷移モデルが完成している必要がある．

\subsubsection{事前条件設定}
シナリオを作成する際，初めに事前条件 (Precondition)を設定する．事前条件の設定では任意の画面から画面インスタンスを作成するか，既存の画面インスタンスを再利用する．この時に画面遷移モデルを読み込む．

事前条件の設定時には，任意の画面クラスまたは画面インスタンスを開発者が選択し，本ツールが認識する必要がある．そこで，ModelObserverを利用する．選択状態の変化の通知をModelObserverから受け，選択した要素を取得する．

この時，選択した画面クラスあるいは画面インスタンスをComponentManagerを用いて表示する．さらに，入力された値で画面インスタンスを作成し，Preconditionに画面インスタンスを追加する．

\subsubsection{対象システムのシミュレート}
\label{sec:simulate}

対象システムのシミュレートには，Browserを使用する．Browserはユーザーの操作によって遷移を決定し，その意図および入力された値をHistoryに格納する．

このとき，値はScreenStateとして保存される．ScreenStateには入力された項目，対象の画面，遷移の意図，画面インスタンス名，意図の対象のインスタンスが格納される．これらの値は，シナリオの作成に用いる．

また，ScreenStateを一つの単位とし，Undo，Redo操作を実現した．値の入力は間違える可能性があり，その際に最初から作成し直すことは明白にコストが高いためである．実装は二つのスタックを用いた（図\ref{fig:undo_redo}）．通常の入力値はスタックhistoryへ格納していく．Undo操作を行う際にはhistoryから一つ取り出し，一時的なスタックtemporaryへ格納する．Redo操作を行う際にはtemporaryから一つ取り出し，historyへ格納する．

\begin{figure}[htbp]
\caption{未完成}
\label{fig:undo_redo}
\end{figure}

また，Browserは現在シミュレートしているシステムの内部状態(internalState) を，画面インスタンスの集合として持つ．これにより，更新の意図や削除の意図で遷移する際に，既存の画面インスタンスを再利用できる．しかしこの時，Undo/Redo操作による内部状態の変更が問題になる．取り消された操作により値が更新されていた場合，更新される前の値が保存されていないため，内部状態に不整合が起こる．

この問題に対応するため，二つの解決策を考案した．

一つは，ScreenStateに内部状態を持たせ，Undo/Redoする度に内部状態を更新する方法である．この方法はメモリーの消費が大きいが，計算時間を抑えられる．

もう一つは，Undo/Redoする度に内部状態を再度計算しなおす方法である．この方法はメモリーの消費は小さいが，計算時間がかかる．

双方実装し使用したところ，顕著な差は見られなかった．従って，今回は後者の方法を採用した．

\subsection{シナリオの導出}
\label{sec:createScenario}

最後に，シナリオを導出する．これは本ツールが自動で行う．また，実際にオブジェクト図を操作する必要があるため，AstahModelEditorを使用する．

導出にはHistoryとPreconditionを用いる．以下に導出の手順を示す．

最初に，Preconditionを生成する．これには与えられたPreconditionをすべてオブジェクト図に書き出す．

次に，Startを生成する．一番初めの画面インスタンスはHistoryの底に格納されているため，これをオブジェクト図に書き出す．

次にシナリオの核となるIntentionを生成する．Historyを順番に参照し，オブジェクト図に書き出していく．この時，画面に入る際の意図が無い場合，シナリオの構成上必要がないと判断し，書き出されない．

また，意図の変わり目は意図Createによる遷移と意図Updateによる遷移の間にあると考えた[要検証]．そこで，意図Createによる遷移の後を状態Createとし，意図Updateによる遷移の後を状態Updateして，状態が変化したときを意図の変わり目とした．また，初期状態は最初に行われた意図Createもしくは意図Updateの遷移により決定する．

Intentionの生成と並行し，Postconditionを生成する．Postconditionは最終的なシナリオの状態なので，Preconditionと各Intentionを合成したものになる．そのため，Intentionと同時に生成し，オブジェクト図に書き出す．

最後にEndを生成する．Historyの最後の要素をオブジェクト図に書き出す．

\section{評価}
\subsection{評価方法}
[この章は評価計画が確定した後，記述する．]

\subsection{考察・結果}
[この章は評価実験の後，記述する．]

\newpage

\section{結論}
\subsection{まとめ}
本論文では，ソフトウェア開発の上流工程においてユーザビリティに関する問題を発見するための手法\endnotemark[1]で提案されるシナリオの作成支援ツールの実装を紹介，説明した．これにより，手法を適用する障壁が取り除かれ，実際の開発において上流工程に手法\endnotemark[1]を取り入れることを可能にした[要検証・要追記]．

本ツールにより，上流工程においてユーザビリティ評価が行われ，より品質の良い製品が開発されることを期待する．
\subsection{今後の課題}
今後の課題として，コンポーネントの表現の柔軟化が挙げられる．現在，コンポーネントは決まった種類の部品のみ定義されている．しかし，現実にはコンポーネントがコンポーネントを内包したり，他のコンポーネントに関係付けられたりと，様々なコンポーネントが存在する．これの改善案として，コンポーネントの表現を拡張可能にする案が挙げられる．これにより，現実に即したコンポーネントの構成が行える．また，複数選択の選択肢の指定も併せて定義されると良い．

また，他の手法に対して支援を行うことも今後の課題としたい．本ツールは特定の手法\endnotemark[1]にのみ適応できるが，画面遷移モデルが存在し，テストシナリオの生成を目的とする手法であれば支援を行える可能性がある．

[評価実験の後，追記する]
\newpage
\addcontentsline{toc}{section}{\notesname}
\theendnotes
\end{document}